{
  "version": 3,
  "sources": ["../../ol/TileRange.js", "../../ol/array.js", "../../ol/size.js", "../../ol/tilecoord.js"],
  "sourcesContent": ["/**\n * @module ol/TileRange\n */\n\n/**\n * A representation of a contiguous block of tiles.  A tile range is specified\n * by its min/max tile coordinates and is inclusive of coordinates.\n */\nclass TileRange {\n  /**\n   * @param {number} minX Minimum X.\n   * @param {number} maxX Maximum X.\n   * @param {number} minY Minimum Y.\n   * @param {number} maxY Maximum Y.\n   */\n  constructor(minX, maxX, minY, maxY) {\n    /**\n     * @type {number}\n     */\n    this.minX = minX;\n\n    /**\n     * @type {number}\n     */\n    this.maxX = maxX;\n\n    /**\n     * @type {number}\n     */\n    this.minY = minY;\n\n    /**\n     * @type {number}\n     */\n    this.maxY = maxY;\n  }\n\n  /**\n   * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @return {boolean} Contains tile coordinate.\n   */\n  contains(tileCoord) {\n    return this.containsXY(tileCoord[1], tileCoord[2]);\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Contains.\n   */\n  containsTileRange(tileRange) {\n    return (\n      this.minX <= tileRange.minX &&\n      tileRange.maxX <= this.maxX &&\n      this.minY <= tileRange.minY &&\n      tileRange.maxY <= this.maxY\n    );\n  }\n\n  /**\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @return {boolean} Contains coordinate.\n   */\n  containsXY(x, y) {\n    return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Equals.\n   */\n  equals(tileRange) {\n    return (\n      this.minX == tileRange.minX &&\n      this.minY == tileRange.minY &&\n      this.maxX == tileRange.maxX &&\n      this.maxY == tileRange.maxY\n    );\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   */\n  extend(tileRange) {\n    if (tileRange.minX < this.minX) {\n      this.minX = tileRange.minX;\n    }\n    if (tileRange.maxX > this.maxX) {\n      this.maxX = tileRange.maxX;\n    }\n    if (tileRange.minY < this.minY) {\n      this.minY = tileRange.minY;\n    }\n    if (tileRange.maxY > this.maxY) {\n      this.maxY = tileRange.maxY;\n    }\n  }\n\n  /**\n   * @return {number} Height.\n   */\n  getHeight() {\n    return this.maxY - this.minY + 1;\n  }\n\n  /**\n   * @return {import(\"./size.js\").Size} Size.\n   */\n  getSize() {\n    return [this.getWidth(), this.getHeight()];\n  }\n\n  /**\n   * @return {number} Width.\n   */\n  getWidth() {\n    return this.maxX - this.minX + 1;\n  }\n\n  /**\n   * @param {TileRange} tileRange Tile range.\n   * @return {boolean} Intersects.\n   */\n  intersects(tileRange) {\n    return (\n      this.minX <= tileRange.maxX &&\n      this.maxX >= tileRange.minX &&\n      this.minY <= tileRange.maxY &&\n      this.maxY >= tileRange.minY\n    );\n  }\n}\n\n/**\n * @param {number} minX Minimum X.\n * @param {number} maxX Maximum X.\n * @param {number} minY Minimum Y.\n * @param {number} maxY Maximum Y.\n * @param {TileRange} [tileRange] TileRange.\n * @return {TileRange} Tile range.\n */\nexport function createOrUpdate(minX, maxX, minY, maxY, tileRange) {\n  if (tileRange !== undefined) {\n    tileRange.minX = minX;\n    tileRange.maxX = maxX;\n    tileRange.minY = minY;\n    tileRange.maxY = maxY;\n    return tileRange;\n  } else {\n    return new TileRange(minX, maxX, minY, maxY);\n  }\n}\n\nexport default TileRange;\n", "/**\n * @module ol/array\n */\n\n/**\n * Performs a binary search on the provided sorted list and returns the index of the item if found. If it can't be found it'll return -1.\n * https://github.com/darkskyapp/binary-search\n *\n * @param {Array<*>} haystack Items to search through.\n * @param {*} needle The item to look for.\n * @param {Function} [comparator] Comparator function.\n * @return {number} The index of the item if found, -1 if not.\n */\nexport function binarySearch(haystack, needle, comparator) {\n  let mid, cmp;\n  comparator = comparator || numberSafeCompareFunction;\n  let low = 0;\n  let high = haystack.length;\n  let found = false;\n\n  while (low < high) {\n    /* Note that \"(low + high) >>> 1\" may overflow, and results in a typecast\n     * to double (which gives the wrong results). */\n    mid = low + ((high - low) >> 1);\n    cmp = +comparator(haystack[mid], needle);\n\n    if (cmp < 0.0) {\n      /* Too low. */\n      low = mid + 1;\n    } else {\n      /* Key found or too high */\n      high = mid;\n      found = !cmp;\n    }\n  }\n\n  /* Key not found. */\n  return found ? low : ~low;\n}\n\n/**\n * Compare function for array sort that is safe for numbers.\n * @param {*} a The first object to be compared.\n * @param {*} b The second object to be compared.\n * @return {number} A negative number, zero, or a positive number as the first\n *     argument is less than, equal to, or greater than the second.\n */\nexport function numberSafeCompareFunction(a, b) {\n  return a > b ? 1 : a < b ? -1 : 0;\n}\n\n/**\n * {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution} can use a function\n * of this type to determine which nearest resolution to use.\n *\n * This function takes a `{number}` representing a value between two array entries,\n * a `{number}` representing the value of the nearest higher entry and\n * a `{number}` representing the value of the nearest lower entry\n * as arguments and returns a `{number}`. If a negative number or zero is returned\n * the lower value will be used, if a positive number is returned the higher value\n * will be used.\n * @typedef {function(number, number, number): number} NearestDirectionFunction\n * @api\n */\n\n/**\n * @param {Array<number>} arr Array in descending order.\n * @param {number} target Target.\n * @param {number|NearestDirectionFunction} direction\n *    0 means return the nearest,\n *    > 0 means return the largest nearest,\n *    < 0 means return the smallest nearest.\n * @return {number} Index.\n */\nexport function linearFindNearest(arr, target, direction) {\n  const n = arr.length;\n  if (arr[0] <= target) {\n    return 0;\n  } else if (target <= arr[n - 1]) {\n    return n - 1;\n  } else {\n    let i;\n    if (direction > 0) {\n      for (i = 1; i < n; ++i) {\n        if (arr[i] < target) {\n          return i - 1;\n        }\n      }\n    } else if (direction < 0) {\n      for (i = 1; i < n; ++i) {\n        if (arr[i] <= target) {\n          return i;\n        }\n      }\n    } else {\n      for (i = 1; i < n; ++i) {\n        if (arr[i] == target) {\n          return i;\n        } else if (arr[i] < target) {\n          if (typeof direction === 'function') {\n            if (direction(target, arr[i - 1], arr[i]) > 0) {\n              return i - 1;\n            } else {\n              return i;\n            }\n          } else if (arr[i - 1] - target < target - arr[i]) {\n            return i - 1;\n          } else {\n            return i;\n          }\n        }\n      }\n    }\n    return n - 1;\n  }\n}\n\n/**\n * @param {Array<*>} arr Array.\n * @param {number} begin Begin index.\n * @param {number} end End index.\n */\nexport function reverseSubArray(arr, begin, end) {\n  while (begin < end) {\n    const tmp = arr[begin];\n    arr[begin] = arr[end];\n    arr[end] = tmp;\n    ++begin;\n    --end;\n  }\n}\n\n/**\n * @param {Array<VALUE>} arr The array to modify.\n * @param {!Array<VALUE>|VALUE} data The elements or arrays of elements to add to arr.\n * @template VALUE\n */\nexport function extend(arr, data) {\n  const extension = Array.isArray(data) ? data : [data];\n  const length = extension.length;\n  for (let i = 0; i < length; i++) {\n    arr[arr.length] = extension[i];\n  }\n}\n\n/**\n * @param {Array<VALUE>} arr The array to modify.\n * @param {VALUE} obj The element to remove.\n * @template VALUE\n * @return {boolean} If the element was removed.\n */\nexport function remove(arr, obj) {\n  const i = arr.indexOf(obj);\n  const found = i > -1;\n  if (found) {\n    arr.splice(i, 1);\n  }\n  return found;\n}\n\n/**\n * @param {Array|Uint8ClampedArray} arr1 The first array to compare.\n * @param {Array|Uint8ClampedArray} arr2 The second array to compare.\n * @return {boolean} Whether the two arrays are equal.\n */\nexport function equals(arr1, arr2) {\n  const len1 = arr1.length;\n  if (len1 !== arr2.length) {\n    return false;\n  }\n  for (let i = 0; i < len1; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Sort the passed array such that the relative order of equal elements is preserved.\n * See https://en.wikipedia.org/wiki/Sorting_algorithm#Stability for details.\n * @param {Array<*>} arr The array to sort (modifies original).\n * @param {!function(*, *): number} compareFnc Comparison function.\n * @api\n */\nexport function stableSort(arr, compareFnc) {\n  const length = arr.length;\n  const tmp = Array(arr.length);\n  let i;\n  for (i = 0; i < length; i++) {\n    tmp[i] = {index: i, value: arr[i]};\n  }\n  tmp.sort(function (a, b) {\n    return compareFnc(a.value, b.value) || a.index - b.index;\n  });\n  for (i = 0; i < arr.length; i++) {\n    arr[i] = tmp[i].value;\n  }\n}\n\n/**\n * @param {Array<*>} arr The array to test.\n * @param {Function} [func] Comparison function.\n * @param {boolean} [strict] Strictly sorted (default false).\n * @return {boolean} Return index.\n */\nexport function isSorted(arr, func, strict) {\n  const compare = func || numberSafeCompareFunction;\n  return arr.every(function (currentVal, index) {\n    if (index === 0) {\n      return true;\n    }\n    const res = compare(arr[index - 1], currentVal);\n    return !(res > 0 || (strict && res === 0));\n  });\n}\n", "/**\n * @module ol/size\n */\n\n/**\n * An array of numbers representing a size: `[width, height]`.\n * @typedef {Array<number>} Size\n * @api\n */\n\n/**\n * Returns a buffered size.\n * @param {Size} size Size.\n * @param {number} num The amount by which to buffer.\n * @param {Size} [dest] Optional reusable size array.\n * @return {Size} The buffered size.\n */\nexport function buffer(size, num, dest) {\n  if (dest === undefined) {\n    dest = [0, 0];\n  }\n  dest[0] = size[0] + 2 * num;\n  dest[1] = size[1] + 2 * num;\n  return dest;\n}\n\n/**\n * Determines if a size has a positive area.\n * @param {Size} size The size to test.\n * @return {boolean} The size has a positive area.\n */\nexport function hasArea(size) {\n  return size[0] > 0 && size[1] > 0;\n}\n\n/**\n * Returns a size scaled by a ratio. The result will be an array of integers.\n * @param {Size} size Size.\n * @param {number} ratio Ratio.\n * @param {Size} [dest] Optional reusable size array.\n * @return {Size} The scaled size.\n */\nexport function scale(size, ratio, dest) {\n  if (dest === undefined) {\n    dest = [0, 0];\n  }\n  dest[0] = (size[0] * ratio + 0.5) | 0;\n  dest[1] = (size[1] * ratio + 0.5) | 0;\n  return dest;\n}\n\n/**\n * Returns an `Size` array for the passed in number (meaning: square) or\n * `Size` array.\n * (meaning: non-square),\n * @param {number|Size} size Width and height.\n * @param {Size} [dest] Optional reusable size array.\n * @return {Size} Size.\n * @api\n */\nexport function toSize(size, dest) {\n  if (Array.isArray(size)) {\n    return size;\n  } else {\n    if (dest === undefined) {\n      dest = [size, size];\n    } else {\n      dest[0] = size;\n      dest[1] = size;\n    }\n    return dest;\n  }\n}\n", "/**\n * @module ol/tilecoord\n */\n\n/**\n * An array of three numbers representing the location of a tile in a tile\n * grid. The order is `z` (zoom level), `x` (column), and `y` (row).\n * @typedef {Array<number>} TileCoord\n * @api\n */\n\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {TileCoord} [tileCoord] Tile coordinate.\n * @return {TileCoord} Tile coordinate.\n */\nexport function createOrUpdate(z, x, y, tileCoord) {\n  if (tileCoord !== undefined) {\n    tileCoord[0] = z;\n    tileCoord[1] = x;\n    tileCoord[2] = y;\n    return tileCoord;\n  } else {\n    return [z, x, y];\n  }\n}\n\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {string} Key.\n */\nexport function getKeyZXY(z, x, y) {\n  return z + '/' + x + '/' + y;\n}\n\n/**\n * Get the key for a tile coord.\n * @param {TileCoord} tileCoord The tile coord.\n * @return {string} Key.\n */\nexport function getKey(tileCoord) {\n  return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);\n}\n\n/**\n * Get the tile cache key for a tile key obtained through `tile.getKey()`.\n * @param {string} tileKey The tile key.\n * @return {string} The cache key.\n */\nexport function getCacheKeyForTileKey(tileKey) {\n  const [z, x, y] = tileKey\n    .substring(tileKey.lastIndexOf('/') + 1, tileKey.length)\n    .split(',')\n    .map(Number);\n  return getKeyZXY(z, x, y);\n}\n\n/**\n * Get a tile coord given a key.\n * @param {string} key The tile coord key.\n * @return {TileCoord} The tile coord.\n */\nexport function fromKey(key) {\n  return key.split('/').map(Number);\n}\n\n/**\n * @param {TileCoord} tileCoord Tile coord.\n * @return {number} Hash.\n */\nexport function hash(tileCoord) {\n  return (tileCoord[1] << tileCoord[0]) + tileCoord[2];\n}\n\n/**\n * @param {TileCoord} tileCoord Tile coordinate.\n * @param {!import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {boolean} Tile coordinate is within extent and zoom level range.\n */\nexport function withinExtentAndZ(tileCoord, tileGrid) {\n  const z = tileCoord[0];\n  const x = tileCoord[1];\n  const y = tileCoord[2];\n\n  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {\n    return false;\n  }\n  const tileRange = tileGrid.getFullTileRange(z);\n  if (!tileRange) {\n    return true;\n  } else {\n    return tileRange.containsXY(x, y);\n  }\n}\n"],
  "mappings": "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",
  "names": ["createOrUpdate"]
}
